#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VoiceRecognize 完全独立版应用（使用Conda）
自动创建conda环境、安装依赖、下载模型、启动Web服务
"""

import os
import sys
import subprocess
import importlib
import webbrowser
import time
import socket
import json
import threading
from pathlib import Path

def check_conda():
    """检查conda是否可用"""
    try:
        result = subprocess.run(['conda', '--version'], 
                              capture_output=True, text=True, check=True)
        print(f"✅ 找到Conda: {result.stdout.strip()}")
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("❌ 未找到Conda，请先安装Miniconda")
        print("下载地址: https://docs.conda.io/en/latest/miniconda.html")
        return False

def create_conda_environment():
    """创建conda环境"""
    env_name = "voicerecognize_standalone"
    
    print(f"🔍 检查conda环境: {env_name}")
    
    # 检查环境是否存在
    try:
        result = subprocess.run(['conda', 'env', 'list'], 
                              capture_output=True, text=True, check=True)
        if env_name in result.stdout:
            print(f"✅ 找到现有环境: {env_name}")
            return env_name
    except subprocess.CalledProcessError:
        pass
    
    print(f"📦 创建新的conda环境: {env_name}")
    try:
        subprocess.run([
            'conda', 'create', '-n', env_name, 'python=3.11', '-y'
        ], check=True)
        print(f"✅ 环境创建成功: {env_name}")
        return env_name
    except subprocess.CalledProcessError as e:
        print(f"❌ 环境创建失败: {e}")
        return None

def install_dependencies(env_name):
    """在conda环境中安装依赖"""
    print(f"📦 在环境 {env_name} 中安装依赖...")
    
    # 安装基础依赖
    try:
        print("安装基础依赖...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'flask', 'requests', 'tqdm', 'psutil', 'soundfile'
        ], check=True)
        print("✅ 基础依赖安装完成")
    except subprocess.CalledProcessError as e:
        print(f"❌ 基础依赖安装失败: {e}")
        return False
    
    # 安装PyTorch
    try:
        print("安装PyTorch...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'torch', 'torchaudio', '--index-url', 'https://download.pytorch.org/whl/cpu'
        ], check=True)
        print("✅ PyTorch安装完成")
    except subprocess.CalledProcessError:
        try:
            print("尝试备用PyTorch安装方式...")
            subprocess.run([
                'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
                'torch', 'torchaudio'
            ], check=True)
            print("✅ PyTorch安装完成")
        except subprocess.CalledProcessError as e:
            print(f"❌ PyTorch安装失败: {e}")
            return False
    
    # 安装Whisper
    try:
        print("安装Whisper...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'openai-whisper'
        ], check=True)
        print("✅ Whisper安装完成")
    except subprocess.CalledProcessError as e:
        print(f"❌ Whisper安装失败: {e}")
        return False
    
    # 安装FFmpeg
    try:
        print("安装FFmpeg...")
        subprocess.run([
            'conda', 'install', '-n', env_name, '-c', 'conda-forge', 'ffmpeg', '-y'
        ], check=True)
        print("✅ FFmpeg安装完成")
    except subprocess.CalledProcessError as e:
        print(f"❌ FFmpeg安装失败: {e}")
        return False
    
    return True

def check_dependencies(env_name):
    """检查依赖是否正确安装"""
    print(f"🔍 检查环境 {env_name} 中的依赖...")
    
    test_script = """
import sys
import importlib

deps = ['flask', 'torch', 'whisper', 'numpy', 'soundfile', 'psutil']
missing = []

for dep in deps:
    try:
        importlib.import_module(dep)
        print(f"✅ {dep}")
    except ImportError:
        print(f"❌ {dep}")
        missing.append(dep)

if missing:
    print(f"缺少依赖: {missing}")
    sys.exit(1)
else:
    print("✅ 所有依赖已正确安装")
"""
    
    try:
        result = subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-c', test_script
        ], capture_output=True, text=True, check=True)
        print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print(f"❌ 依赖检查失败: {e}")
        print(f"错误输出: {e.stderr}")
        return False

def download_models(env_name):
    """下载必要的模型"""
    print(f"\n📥 在环境 {env_name} 中检查模型文件...")
    
    download_script = """
import whisper
import os

print("正在检查Whisper模型...")
try:
    model = whisper.load_model('base')
    print("✅ Whisper模型已就绪")
except Exception as e:
    print(f"📥 正在下载Whisper模型...")
    model = whisper.load_model('base')
    print("✅ Whisper模型下载完成")
"""
    
    try:
        result = subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-c', download_script
        ], capture_output=True, text=True, check=True)
        print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print(f"❌ 模型下载失败: {e}")
        print(f"错误输出: {e.stderr}")
        return False

def find_free_port(start_port=5002):
    """查找可用端口"""
    port = start_port
    while port < 65535:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('localhost', port))
                return port
        except OSError:
            port += 1
    return None

def start_web_app(env_name, port):
    """启动Web应用"""
    print(f"\n🚀 在环境 {env_name} 中启动Web应用...")
    print(f"🌐 应用地址: http://localhost:{port}")
    
    # 创建简化的Web应用脚本
    web_app_script = f'''
import os
import sys
import json
import time
import threading
from flask import Flask, render_template, request, jsonify, send_file
import whisper
from werkzeug.utils import secure_filename

app = Flask(__name__)

# 配置
UPLOAD_FOLDER = 'uploads'
PROCESSED_FOLDER = 'processed'
TEMP_FOLDER = 'temp'
ALLOWED_EXTENSIONS = {{'wav', 'mp3', 'm4a', 'flac', 'aac'}}

# 创建必要的文件夹
for folder in [UPLOAD_FOLDER, PROCESSED_FOLDER, TEMP_FOLDER]:
    os.makedirs(folder, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB

# 全局变量存储任务状态
batch_status = {{
    'running': False,
    'total_files': 0,
    'processed_files': 0,
    'current_file': '',
    'current_progress': 0,
    'current_step': '',
    'results': [],
    'error': None
}}

def allowed_file(filename):
    """检查文件扩展名是否允许"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def process_single_file(audio_file, model_name='base'):
    """处理单个音频文件"""
    try:
        # 加载Whisper模型
        whisper_model = whisper.load_model(model_name)
        
        # 使用Whisper转录
        result = whisper_model.transcribe(
            audio_file,
            language="zh",
            task="transcribe"
        )
        
        return {{
            'file': audio_file,
            'text': result['text'].strip(),
            'language': result.get('language', 'zh'),
            'segments': result.get('segments', [])
        }}
        
    except Exception as e:
        return {{
            'file': audio_file,
            'error': str(e)
        }}

def process_batch_files(file_list, model_name='base'):
    """批量处理文件"""
    global batch_status
    
    batch_status['running'] = True
    batch_status['total_files'] = len(file_list)
    batch_status['processed_files'] = 0
    batch_status['results'] = []
    batch_status['error'] = None
    
    try:
        for i, file_path in enumerate(file_list):
            if not batch_status['running']:
                break
                
            batch_status['current_file'] = os.path.basename(file_path)
            batch_status['current_progress'] = (i / len(file_list)) * 100
            batch_status['current_step'] = f'处理文件 {{i+1}}/{{len(file_list)}}'
            
            print(f"处理文件: {{file_path}}")
            result = process_single_file(file_path, model_name)
            batch_status['results'].append(result)
            batch_status['processed_files'] += 1
            
        batch_status['current_step'] = '处理完成'
        batch_status['current_progress'] = 100
        
    except Exception as e:
        batch_status['error'] = str(e)
        print(f"批量处理错误: {{e}}")
    
    finally:
        batch_status['running'] = False

@app.route('/')
def index():
    """主页"""
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>VoiceRecognize 语音识别</title>
        <meta charset="utf-8">
        <style>
            body {{ font-family: Arial, sans-serif; margin: 40px; }}
            .container {{ max-width: 800px; margin: 0 auto; }}
            .upload-area {{ border: 2px dashed #ccc; padding: 20px; text-align: center; margin: 20px 0; }}
            .file-list {{ margin: 20px 0; }}
            .status {{ margin: 20px 0; padding: 10px; background: #f0f0f0; }}
            button {{ padding: 10px 20px; margin: 5px; cursor: pointer; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>🎤 VoiceRecognize 语音识别</h1>
            <p>支持批量上传音频文件进行语音识别</p>
            
            <div class="upload-area">
                <h3>📁 上传音频文件</h3>
                <input type="file" id="fileInput" multiple accept=".wav,.mp3,.m4a,.flac,.aac">
                <button onclick="uploadFiles()">上传文件</button>
            </div>
            
            <div class="file-list">
                <h3>📋 文件列表</h3>
                <div id="fileList"></div>
            </div>
            
            <div class="status">
                <h3>📊 处理状态</h3>
                <div id="status"></div>
            </div>
            
            <button onclick="startProcessing()">开始处理</button>
            <button onclick="downloadResults()">下载结果</button>
        </div>
        
        <script>
            function uploadFiles() {{
                const files = document.getElementById('fileInput').files;
                const formData = new FormData();
                
                for (let file of files) {{
                    formData.append('files', file);
                }}
                
                fetch('/api/upload', {{
                    method: 'POST',
                    body: formData
                }})
                .then(response => response.json())
                .then(data => {{
                    alert(data.message);
                    loadFiles();
                }});
            }}
            
            function loadFiles() {{
                fetch('/api/files')
                .then(response => response.json())
                .then(data => {{
                    const fileList = document.getElementById('fileList');
                    fileList.innerHTML = '';
                    
                    data.upload_files.forEach(file => {{
                        fileList.innerHTML += `<div>${{file.name}} (${{Math.round(file.size/1024)}}KB)</div>`;
                    }});
                }});
            }}
            
            function startProcessing() {{
                fetch('/api/files')
                .then(response => response.json())
                .then(data => {{
                    const files = data.upload_files.map(f => f.path);
                    
                    fetch('/api/process_batch', {{
                        method: 'POST',
                        headers: {{'Content-Type': 'application/json'}},
                        body: JSON.stringify({{files: files, model: 'base'}})
                    }})
                    .then(response => response.json())
                    .then(data => {{
                        alert(data.message);
                        monitorStatus();
                    }});
                }});
            }}
            
            function monitorStatus() {{
                const statusDiv = document.getElementById('status');
                
                const interval = setInterval(() => {{
                    fetch('/api/batch_status')
                    .then(response => response.json())
                    .then(data => {{
                        statusDiv.innerHTML = `
                            <div>状态: ${{data.running ? '运行中' : '空闲'}}</div>
                            <div>进度: ${{data.current_progress.toFixed(1)}}%</div>
                            <div>当前文件: ${{data.current_file}}</div>
                            <div>步骤: ${{data.current_step}}</div>
                        `;
                        
                        if (!data.running && data.processed_files > 0) {{
                            clearInterval(interval);
                            alert('处理完成！');
                        }}
                    }});
                }}, 1000);
            }}
            
            function downloadResults() {{
                window.open('/api/download_result');
            }}
            
            // 页面加载时获取文件列表
            loadFiles();
        </script>
    </body>
    </html>
    """

@app.route('/api/upload', methods=['POST'])
def upload_files():
    """文件上传API"""
    if 'files' not in request.files:
        return jsonify({{'error': '没有文件'}})
    
    files = request.files.getlist('files')
    uploaded_files = []
    
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            file.save(filepath)
            uploaded_files.append(filename)
    
    return jsonify({{
        'message': f'成功上传 {{len(uploaded_files)}} 个文件',
        'files': uploaded_files
    }})

@app.route('/api/files')
def get_files():
    """获取文件列表API"""
    upload_files = []
    processed_files = []
    
    # 获取上传文件
    for filename in os.listdir(UPLOAD_FOLDER):
        if allowed_file(filename):
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            if os.path.isfile(filepath):
                size = os.path.getsize(filepath)
                upload_files.append({{
                    'name': filename,
                    'path': filepath,
                    'size': size
                }})
    
    # 获取已处理文件
    for filename in os.listdir(PROCESSED_FOLDER):
        if allowed_file(filename):
            filepath = os.path.join(PROCESSED_FOLDER, filename)
            if os.path.isfile(filepath):
                size = os.path.getsize(filepath)
                processed_files.append({{
                    'name': filename,
                    'path': filepath,
                    'size': size
                }})
    
    return jsonify({{
        'upload_files': upload_files,
        'processed_files': processed_files
    }})

@app.route('/api/process_batch', methods=['POST'])
def process_batch():
    """批量处理API"""
    global batch_status
    
    if batch_status['running']:
        return jsonify({{'error': '任务正在运行中'}})
    
    data = request.get_json()
    file_paths = data.get('files', [])
    model_name = data.get('model', 'base')
    
    if not file_paths:
        return jsonify({{'error': '没有选择文件'}})
    
    # 启动后台任务
    thread = threading.Thread(
        target=process_batch_files,
        args=(file_paths, model_name)
    )
    thread.daemon = True
    thread.start()
    
    return jsonify({{'message': '批量处理任务已启动'}})

@app.route('/api/batch_status')
def get_batch_status():
    """获取批量处理状态"""
    return jsonify(batch_status)

@app.route('/api/stop_batch')
def stop_batch():
    """停止批量处理"""
    global batch_status
    batch_status['running'] = False
    return jsonify({{'message': '已停止批量处理'}})

@app.route('/api/download_result')
def download_result():
    """下载处理结果"""
    if not batch_status['results']:
        return jsonify({{'error': '没有可下载的结果'}})
    
    result_file = os.path.join(TEMP_FOLDER, 'batch_results.json')
    with open(result_file, 'w', encoding='utf-8') as f:
        json.dump(batch_status['results'], f, ensure_ascii=False, indent=2)
    
    return send_file(result_file, as_attachment=True, download_name='batch_results.json')

if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0', port={port})
'''
    
    # 将脚本写入临时文件
    script_file = 'web_app.py'
    with open(script_file, 'w', encoding='utf-8') as f:
        f.write(web_app_script)
    
    try:
        # 在conda环境中运行Web应用
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', script_file
        ], check=True)
    except subprocess.CalledProcessError as e:
        print(f"❌ Web应用启动失败: {e}")
        return False
    finally:
        # 清理临时文件
        if os.path.exists(script_file):
            os.remove(script_file)

def main():
    """主函数"""
    print("=== VoiceRecognize 独立版应用（Conda版）===")
    print("正在初始化...")
    
    # 1. 检查conda
    if not check_conda():
        return 1
    
    # 2. 创建conda环境
    env_name = create_conda_environment()
    if not env_name:
        return 1
    
    # 3. 安装依赖
    if not install_dependencies(env_name):
        return 1
    
    # 4. 检查依赖
    if not check_dependencies(env_name):
        return 1
    
    # 5. 下载模型
    if not download_models(env_name):
        return 1
    
    # 6. 查找可用端口
    port = find_free_port()
    if port is None:
        print("❌ 无法找到可用端口")
        return 1
    
    # 7. 自动打开浏览器
    url = f"http://localhost:{port}"
    print(f"\n🌐 应用将在浏览器中打开: {url}")
    print("📱 按 Ctrl+C 停止应用")
    
    # 延迟打开浏览器
    def open_browser():
        time.sleep(3)
        webbrowser.open(url)
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # 8. 启动Web应用
    try:
        start_web_app(env_name, port)
    except KeyboardInterrupt:
        print("\n👋 应用已停止")
    except Exception as e:
        print(f"❌ 应用启动失败: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())