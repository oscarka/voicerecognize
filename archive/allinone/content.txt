#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
VoiceRecognize å®Œå…¨ç‹¬ç«‹ç‰ˆåº”ç”¨ï¼ˆä½¿ç”¨Condaï¼‰
è‡ªåŠ¨åˆ›å»ºcondaç¯å¢ƒã€å®‰è£…ä¾èµ–ã€ä¸‹è½½æ¨¡å‹ã€å¯åŠ¨WebæœåŠ¡
"""

import os
import sys
import subprocess
import importlib
import webbrowser
import time
import socket
import json
import threading
from pathlib import Path

def check_conda():
    """æ£€æŸ¥condaæ˜¯å¦å¯ç”¨"""
    try:
        result = subprocess.run(['conda', '--version'], 
                              capture_output=True, text=True, check=True)
        print(f"âœ… æ‰¾åˆ°Conda: {result.stdout.strip()}")
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("âŒ æœªæ‰¾åˆ°Condaï¼Œè¯·å…ˆå®‰è£…Miniconda")
        print("ä¸‹è½½åœ°å€: https://docs.conda.io/en/latest/miniconda.html")
        return False

def create_conda_environment():
    """åˆ›å»ºcondaç¯å¢ƒ"""
    env_name = "voicerecognize_standalone"
    
    print(f"ğŸ” æ£€æŸ¥condaç¯å¢ƒ: {env_name}")
    
    # æ£€æŸ¥ç¯å¢ƒæ˜¯å¦å­˜åœ¨
    try:
        result = subprocess.run(['conda', 'env', 'list'], 
                              capture_output=True, text=True, check=True)
        if env_name in result.stdout:
            print(f"âœ… æ‰¾åˆ°ç°æœ‰ç¯å¢ƒ: {env_name}")
            return env_name
    except subprocess.CalledProcessError:
        pass
    
    print(f"ğŸ“¦ åˆ›å»ºæ–°çš„condaç¯å¢ƒ: {env_name}")
    try:
        subprocess.run([
            'conda', 'create', '-n', env_name, 'python=3.11', '-y'
        ], check=True)
        print(f"âœ… ç¯å¢ƒåˆ›å»ºæˆåŠŸ: {env_name}")
        return env_name
    except subprocess.CalledProcessError as e:
        print(f"âŒ ç¯å¢ƒåˆ›å»ºå¤±è´¥: {e}")
        return None

def install_dependencies(env_name):
    """åœ¨condaç¯å¢ƒä¸­å®‰è£…ä¾èµ–"""
    print(f"ğŸ“¦ åœ¨ç¯å¢ƒ {env_name} ä¸­å®‰è£…ä¾èµ–...")
    
    # å®‰è£…åŸºç¡€ä¾èµ–
    try:
        print("å®‰è£…åŸºç¡€ä¾èµ–...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'flask', 'requests', 'tqdm', 'psutil', 'soundfile'
        ], check=True)
        print("âœ… åŸºç¡€ä¾èµ–å®‰è£…å®Œæˆ")
    except subprocess.CalledProcessError as e:
        print(f"âŒ åŸºç¡€ä¾èµ–å®‰è£…å¤±è´¥: {e}")
        return False
    
    # å®‰è£…PyTorch
    try:
        print("å®‰è£…PyTorch...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'torch', 'torchaudio', '--index-url', 'https://download.pytorch.org/whl/cpu'
        ], check=True)
        print("âœ… PyTorchå®‰è£…å®Œæˆ")
    except subprocess.CalledProcessError:
        try:
            print("å°è¯•å¤‡ç”¨PyTorchå®‰è£…æ–¹å¼...")
            subprocess.run([
                'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
                'torch', 'torchaudio'
            ], check=True)
            print("âœ… PyTorchå®‰è£…å®Œæˆ")
        except subprocess.CalledProcessError as e:
            print(f"âŒ PyTorchå®‰è£…å¤±è´¥: {e}")
            return False
    
    # å®‰è£…Whisper
    try:
        print("å®‰è£…Whisper...")
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-m', 'pip', 'install',
            'openai-whisper'
        ], check=True)
        print("âœ… Whisperå®‰è£…å®Œæˆ")
    except subprocess.CalledProcessError as e:
        print(f"âŒ Whisperå®‰è£…å¤±è´¥: {e}")
        return False
    
    # å®‰è£…FFmpeg
    try:
        print("å®‰è£…FFmpeg...")
        subprocess.run([
            'conda', 'install', '-n', env_name, '-c', 'conda-forge', 'ffmpeg', '-y'
        ], check=True)
        print("âœ… FFmpegå®‰è£…å®Œæˆ")
    except subprocess.CalledProcessError as e:
        print(f"âŒ FFmpegå®‰è£…å¤±è´¥: {e}")
        return False
    
    return True

def check_dependencies(env_name):
    """æ£€æŸ¥ä¾èµ–æ˜¯å¦æ­£ç¡®å®‰è£…"""
    print(f"ğŸ” æ£€æŸ¥ç¯å¢ƒ {env_name} ä¸­çš„ä¾èµ–...")
    
    test_script = """
import sys
import importlib

deps = ['flask', 'torch', 'whisper', 'numpy', 'soundfile', 'psutil']
missing = []

for dep in deps:
    try:
        importlib.import_module(dep)
        print(f"âœ… {dep}")
    except ImportError:
        print(f"âŒ {dep}")
        missing.append(dep)

if missing:
    print(f"ç¼ºå°‘ä¾èµ–: {missing}")
    sys.exit(1)
else:
    print("âœ… æ‰€æœ‰ä¾èµ–å·²æ­£ç¡®å®‰è£…")
"""
    
    try:
        result = subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-c', test_script
        ], capture_output=True, text=True, check=True)
        print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print(f"âŒ ä¾èµ–æ£€æŸ¥å¤±è´¥: {e}")
        print(f"é”™è¯¯è¾“å‡º: {e.stderr}")
        return False

def download_models(env_name):
    """ä¸‹è½½å¿…è¦çš„æ¨¡å‹"""
    print(f"\nğŸ“¥ åœ¨ç¯å¢ƒ {env_name} ä¸­æ£€æŸ¥æ¨¡å‹æ–‡ä»¶...")
    
    download_script = """
import whisper
import os

print("æ­£åœ¨æ£€æŸ¥Whisperæ¨¡å‹...")
try:
    model = whisper.load_model('base')
    print("âœ… Whisperæ¨¡å‹å·²å°±ç»ª")
except Exception as e:
    print(f"ğŸ“¥ æ­£åœ¨ä¸‹è½½Whisperæ¨¡å‹...")
    model = whisper.load_model('base')
    print("âœ… Whisperæ¨¡å‹ä¸‹è½½å®Œæˆ")
"""
    
    try:
        result = subprocess.run([
            'conda', 'run', '-n', env_name, 'python', '-c', download_script
        ], capture_output=True, text=True, check=True)
        print(result.stdout)
        return True
    except subprocess.CalledProcessError as e:
        print(f"âŒ æ¨¡å‹ä¸‹è½½å¤±è´¥: {e}")
        print(f"é”™è¯¯è¾“å‡º: {e.stderr}")
        return False

def find_free_port(start_port=5002):
    """æŸ¥æ‰¾å¯ç”¨ç«¯å£"""
    port = start_port
    while port < 65535:
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.bind(('localhost', port))
                return port
        except OSError:
            port += 1
    return None

def start_web_app(env_name, port):
    """å¯åŠ¨Webåº”ç”¨"""
    print(f"\nğŸš€ åœ¨ç¯å¢ƒ {env_name} ä¸­å¯åŠ¨Webåº”ç”¨...")
    print(f"ğŸŒ åº”ç”¨åœ°å€: http://localhost:{port}")
    
    # åˆ›å»ºç®€åŒ–çš„Webåº”ç”¨è„šæœ¬
    web_app_script = f'''
import os
import sys
import json
import time
import threading
from flask import Flask, render_template, request, jsonify, send_file
import whisper
from werkzeug.utils import secure_filename

app = Flask(__name__)

# é…ç½®
UPLOAD_FOLDER = 'uploads'
PROCESSED_FOLDER = 'processed'
TEMP_FOLDER = 'temp'
ALLOWED_EXTENSIONS = {{'wav', 'mp3', 'm4a', 'flac', 'aac'}}

# åˆ›å»ºå¿…è¦çš„æ–‡ä»¶å¤¹
for folder in [UPLOAD_FOLDER, PROCESSED_FOLDER, TEMP_FOLDER]:
    os.makedirs(folder, exist_ok=True)

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 500 * 1024 * 1024  # 500MB

# å…¨å±€å˜é‡å­˜å‚¨ä»»åŠ¡çŠ¶æ€
batch_status = {{
    'running': False,
    'total_files': 0,
    'processed_files': 0,
    'current_file': '',
    'current_progress': 0,
    'current_step': '',
    'results': [],
    'error': None
}}

def allowed_file(filename):
    """æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦å…è®¸"""
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS

def process_single_file(audio_file, model_name='base'):
    """å¤„ç†å•ä¸ªéŸ³é¢‘æ–‡ä»¶"""
    try:
        # åŠ è½½Whisperæ¨¡å‹
        whisper_model = whisper.load_model(model_name)
        
        # ä½¿ç”¨Whisperè½¬å½•
        result = whisper_model.transcribe(
            audio_file,
            language="zh",
            task="transcribe"
        )
        
        return {{
            'file': audio_file,
            'text': result['text'].strip(),
            'language': result.get('language', 'zh'),
            'segments': result.get('segments', [])
        }}
        
    except Exception as e:
        return {{
            'file': audio_file,
            'error': str(e)
        }}

def process_batch_files(file_list, model_name='base'):
    """æ‰¹é‡å¤„ç†æ–‡ä»¶"""
    global batch_status
    
    batch_status['running'] = True
    batch_status['total_files'] = len(file_list)
    batch_status['processed_files'] = 0
    batch_status['results'] = []
    batch_status['error'] = None
    
    try:
        for i, file_path in enumerate(file_list):
            if not batch_status['running']:
                break
                
            batch_status['current_file'] = os.path.basename(file_path)
            batch_status['current_progress'] = (i / len(file_list)) * 100
            batch_status['current_step'] = f'å¤„ç†æ–‡ä»¶ {{i+1}}/{{len(file_list)}}'
            
            print(f"å¤„ç†æ–‡ä»¶: {{file_path}}")
            result = process_single_file(file_path, model_name)
            batch_status['results'].append(result)
            batch_status['processed_files'] += 1
            
        batch_status['current_step'] = 'å¤„ç†å®Œæˆ'
        batch_status['current_progress'] = 100
        
    except Exception as e:
        batch_status['error'] = str(e)
        print(f"æ‰¹é‡å¤„ç†é”™è¯¯: {{e}}")
    
    finally:
        batch_status['running'] = False

@app.route('/')
def index():
    """ä¸»é¡µ"""
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>VoiceRecognize è¯­éŸ³è¯†åˆ«</title>
        <meta charset="utf-8">
        <style>
            body {{ font-family: Arial, sans-serif; margin: 40px; }}
            .container {{ max-width: 800px; margin: 0 auto; }}
            .upload-area {{ border: 2px dashed #ccc; padding: 20px; text-align: center; margin: 20px 0; }}
            .file-list {{ margin: 20px 0; }}
            .status {{ margin: 20px 0; padding: 10px; background: #f0f0f0; }}
            button {{ padding: 10px 20px; margin: 5px; cursor: pointer; }}
        </style>
    </head>
    <body>
        <div class="container">
            <h1>ğŸ¤ VoiceRecognize è¯­éŸ³è¯†åˆ«</h1>
            <p>æ”¯æŒæ‰¹é‡ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶è¿›è¡Œè¯­éŸ³è¯†åˆ«</p>
            
            <div class="upload-area">
                <h3>ğŸ“ ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶</h3>
                <input type="file" id="fileInput" multiple accept=".wav,.mp3,.m4a,.flac,.aac">
                <button onclick="uploadFiles()">ä¸Šä¼ æ–‡ä»¶</button>
            </div>
            
            <div class="file-list">
                <h3>ğŸ“‹ æ–‡ä»¶åˆ—è¡¨</h3>
                <div id="fileList"></div>
            </div>
            
            <div class="status">
                <h3>ğŸ“Š å¤„ç†çŠ¶æ€</h3>
                <div id="status"></div>
            </div>
            
            <button onclick="startProcessing()">å¼€å§‹å¤„ç†</button>
            <button onclick="downloadResults()">ä¸‹è½½ç»“æœ</button>
        </div>
        
        <script>
            function uploadFiles() {{
                const files = document.getElementById('fileInput').files;
                const formData = new FormData();
                
                for (let file of files) {{
                    formData.append('files', file);
                }}
                
                fetch('/api/upload', {{
                    method: 'POST',
                    body: formData
                }})
                .then(response => response.json())
                .then(data => {{
                    alert(data.message);
                    loadFiles();
                }});
            }}
            
            function loadFiles() {{
                fetch('/api/files')
                .then(response => response.json())
                .then(data => {{
                    const fileList = document.getElementById('fileList');
                    fileList.innerHTML = '';
                    
                    data.upload_files.forEach(file => {{
                        fileList.innerHTML += `<div>${{file.name}} (${{Math.round(file.size/1024)}}KB)</div>`;
                    }});
                }});
            }}
            
            function startProcessing() {{
                fetch('/api/files')
                .then(response => response.json())
                .then(data => {{
                    const files = data.upload_files.map(f => f.path);
                    
                    fetch('/api/process_batch', {{
                        method: 'POST',
                        headers: {{'Content-Type': 'application/json'}},
                        body: JSON.stringify({{files: files, model: 'base'}})
                    }})
                    .then(response => response.json())
                    .then(data => {{
                        alert(data.message);
                        monitorStatus();
                    }});
                }});
            }}
            
            function monitorStatus() {{
                const statusDiv = document.getElementById('status');
                
                const interval = setInterval(() => {{
                    fetch('/api/batch_status')
                    .then(response => response.json())
                    .then(data => {{
                        statusDiv.innerHTML = `
                            <div>çŠ¶æ€: ${{data.running ? 'è¿è¡Œä¸­' : 'ç©ºé—²'}}</div>
                            <div>è¿›åº¦: ${{data.current_progress.toFixed(1)}}%</div>
                            <div>å½“å‰æ–‡ä»¶: ${{data.current_file}}</div>
                            <div>æ­¥éª¤: ${{data.current_step}}</div>
                        `;
                        
                        if (!data.running && data.processed_files > 0) {{
                            clearInterval(interval);
                            alert('å¤„ç†å®Œæˆï¼');
                        }}
                    }});
                }}, 1000);
            }}
            
            function downloadResults() {{
                window.open('/api/download_result');
            }}
            
            // é¡µé¢åŠ è½½æ—¶è·å–æ–‡ä»¶åˆ—è¡¨
            loadFiles();
        </script>
    </body>
    </html>
    """

@app.route('/api/upload', methods=['POST'])
def upload_files():
    """æ–‡ä»¶ä¸Šä¼ API"""
    if 'files' not in request.files:
        return jsonify({{'error': 'æ²¡æœ‰æ–‡ä»¶'}})
    
    files = request.files.getlist('files')
    uploaded_files = []
    
    for file in files:
        if file and allowed_file(file.filename):
            filename = secure_filename(file.filename)
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            file.save(filepath)
            uploaded_files.append(filename)
    
    return jsonify({{
        'message': f'æˆåŠŸä¸Šä¼  {{len(uploaded_files)}} ä¸ªæ–‡ä»¶',
        'files': uploaded_files
    }})

@app.route('/api/files')
def get_files():
    """è·å–æ–‡ä»¶åˆ—è¡¨API"""
    upload_files = []
    processed_files = []
    
    # è·å–ä¸Šä¼ æ–‡ä»¶
    for filename in os.listdir(UPLOAD_FOLDER):
        if allowed_file(filename):
            filepath = os.path.join(UPLOAD_FOLDER, filename)
            if os.path.isfile(filepath):
                size = os.path.getsize(filepath)
                upload_files.append({{
                    'name': filename,
                    'path': filepath,
                    'size': size
                }})
    
    # è·å–å·²å¤„ç†æ–‡ä»¶
    for filename in os.listdir(PROCESSED_FOLDER):
        if allowed_file(filename):
            filepath = os.path.join(PROCESSED_FOLDER, filename)
            if os.path.isfile(filepath):
                size = os.path.getsize(filepath)
                processed_files.append({{
                    'name': filename,
                    'path': filepath,
                    'size': size
                }})
    
    return jsonify({{
        'upload_files': upload_files,
        'processed_files': processed_files
    }})

@app.route('/api/process_batch', methods=['POST'])
def process_batch():
    """æ‰¹é‡å¤„ç†API"""
    global batch_status
    
    if batch_status['running']:
        return jsonify({{'error': 'ä»»åŠ¡æ­£åœ¨è¿è¡Œä¸­'}})
    
    data = request.get_json()
    file_paths = data.get('files', [])
    model_name = data.get('model', 'base')
    
    if not file_paths:
        return jsonify({{'error': 'æ²¡æœ‰é€‰æ‹©æ–‡ä»¶'}})
    
    # å¯åŠ¨åå°ä»»åŠ¡
    thread = threading.Thread(
        target=process_batch_files,
        args=(file_paths, model_name)
    )
    thread.daemon = True
    thread.start()
    
    return jsonify({{'message': 'æ‰¹é‡å¤„ç†ä»»åŠ¡å·²å¯åŠ¨'}})

@app.route('/api/batch_status')
def get_batch_status():
    """è·å–æ‰¹é‡å¤„ç†çŠ¶æ€"""
    return jsonify(batch_status)

@app.route('/api/stop_batch')
def stop_batch():
    """åœæ­¢æ‰¹é‡å¤„ç†"""
    global batch_status
    batch_status['running'] = False
    return jsonify({{'message': 'å·²åœæ­¢æ‰¹é‡å¤„ç†'}})

@app.route('/api/download_result')
def download_result():
    """ä¸‹è½½å¤„ç†ç»“æœ"""
    if not batch_status['results']:
        return jsonify({{'error': 'æ²¡æœ‰å¯ä¸‹è½½çš„ç»“æœ'}})
    
    result_file = os.path.join(TEMP_FOLDER, 'batch_results.json')
    with open(result_file, 'w', encoding='utf-8') as f:
        json.dump(batch_status['results'], f, ensure_ascii=False, indent=2)
    
    return send_file(result_file, as_attachment=True, download_name='batch_results.json')

if __name__ == '__main__':
    app.run(debug=False, host='0.0.0.0', port={port})
'''
    
    # å°†è„šæœ¬å†™å…¥ä¸´æ—¶æ–‡ä»¶
    script_file = 'web_app.py'
    with open(script_file, 'w', encoding='utf-8') as f:
        f.write(web_app_script)
    
    try:
        # åœ¨condaç¯å¢ƒä¸­è¿è¡ŒWebåº”ç”¨
        subprocess.run([
            'conda', 'run', '-n', env_name, 'python', script_file
        ], check=True)
    except subprocess.CalledProcessError as e:
        print(f"âŒ Webåº”ç”¨å¯åŠ¨å¤±è´¥: {e}")
        return False
    finally:
        # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
        if os.path.exists(script_file):
            os.remove(script_file)

def main():
    """ä¸»å‡½æ•°"""
    print("=== VoiceRecognize ç‹¬ç«‹ç‰ˆåº”ç”¨ï¼ˆCondaç‰ˆï¼‰===")
    print("æ­£åœ¨åˆå§‹åŒ–...")
    
    # 1. æ£€æŸ¥conda
    if not check_conda():
        return 1
    
    # 2. åˆ›å»ºcondaç¯å¢ƒ
    env_name = create_conda_environment()
    if not env_name:
        return 1
    
    # 3. å®‰è£…ä¾èµ–
    if not install_dependencies(env_name):
        return 1
    
    # 4. æ£€æŸ¥ä¾èµ–
    if not check_dependencies(env_name):
        return 1
    
    # 5. ä¸‹è½½æ¨¡å‹
    if not download_models(env_name):
        return 1
    
    # 6. æŸ¥æ‰¾å¯ç”¨ç«¯å£
    port = find_free_port()
    if port is None:
        print("âŒ æ— æ³•æ‰¾åˆ°å¯ç”¨ç«¯å£")
        return 1
    
    # 7. è‡ªåŠ¨æ‰“å¼€æµè§ˆå™¨
    url = f"http://localhost:{port}"
    print(f"\nğŸŒ åº”ç”¨å°†åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€: {url}")
    print("ğŸ“± æŒ‰ Ctrl+C åœæ­¢åº”ç”¨")
    
    # å»¶è¿Ÿæ‰“å¼€æµè§ˆå™¨
    def open_browser():
        time.sleep(3)
        webbrowser.open(url)
    
    browser_thread = threading.Thread(target=open_browser)
    browser_thread.daemon = True
    browser_thread.start()
    
    # 8. å¯åŠ¨Webåº”ç”¨
    try:
        start_web_app(env_name, port)
    except KeyboardInterrupt:
        print("\nğŸ‘‹ åº”ç”¨å·²åœæ­¢")
    except Exception as e:
        print(f"âŒ åº”ç”¨å¯åŠ¨å¤±è´¥: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    sys.exit(main())